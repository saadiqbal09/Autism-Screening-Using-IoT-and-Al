import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import sounddevice as sd
from scipy.io.wavfile import write
import torch
from transformers import pipeline
import numpy as np
import string
import os
import threading
import queue

# --- Configuration ---
FILENAME = "child_response.wav"
SAMPLE_RATE = 16000
# Using 'openai/whisper-medium' for robust multilingual support.
# If this is too slow on your laptop, change it to "openai/whisper-small"
MODEL_ID = "openai/whisper-medium" 

class ASDScreeningApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Drishti AI - ASD Screening Tool")
        self.root.geometry("700x850")
        self.root.configure(bg="#f0f0f0")

        # Variables
        self.is_recording = False
        self.audio_frames = []
        self.model = None
        # Map friendly names to Whisper language codes
        self.language_map = {
            "English": "english",
            "Hindi": "hindi",
            "Marathi": "marathi",
            "Tamil": "tamil",
            "Bengali": "bengali",
            "Gujarati": "gujarati",
            "Telugu": "telugu"
        }

        # UI Elements
        self.create_widgets()
        
        # Load model in a separate thread to keep UI responsive
        self.status_var.set("â³ Loading AI Model... This may take a minute.")
        threading.Thread(target=self.load_model, daemon=True).start()

    def create_widgets(self):
        # Header
        header_frame = tk.Frame(self.root, bg="#2c3e50", pady=20)
        header_frame.pack(fill="x")
        
        title_label = tk.Label(header_frame, text="Drishti AI: Autism Screening", 
                               font=("Segoe UI", 24, "bold"), fg="white", bg="#2c3e50")
        title_label.pack()
        
        subtitle_label = tk.Label(header_frame, text="Smart Voice & Speech Pattern Analysis", 
                                  font=("Segoe UI", 12), fg="#ecf0f1", bg="#2c3e50")
        subtitle_label.pack()

        # Controls Section
        control_frame = tk.LabelFrame(self.root, text="Test Controls", font=("Segoe UI", 12, "bold"), bg="#f0f0f0", padx=20, pady=20)
        control_frame.pack(pady=20, padx=20, fill="x")

        # Language Selection
        lang_frame = tk.Frame(control_frame, bg="#f0f0f0")
        lang_frame.pack(fill="x", pady=5)
        tk.Label(lang_frame, text="Select Child's Language:", font=("Segoe UI", 11), bg="#f0f0f0").pack(side="left")
        self.lang_combo = ttk.Combobox(lang_frame, values=list(self.language_map.keys()), state="readonly", font=("Segoe UI", 11), width=15)
        self.lang_combo.current(0) # Default to English
        self.lang_combo.pack(side="left", padx=10)

        # Buttons
        btn_frame = tk.Frame(control_frame, bg="#f0f0f0")
        btn_frame.pack(pady=20)

        self.start_btn = tk.Button(btn_frame, text=" Start Recording", command=self.start_recording,
                                   font=("Segoe UI", 12, "bold"), bg="#e74c3c", fg="white", width=18, height=2, cursor="hand2")
        self.start_btn.pack(side="left", padx=10)

        self.stop_btn = tk.Button(btn_frame, text="â¬› Stop & Analyze", command=self.stop_recording,
                                  font=("Segoe UI", 12, "bold"), bg="#34495e", fg="white", width=18, height=2, state="disabled", cursor="hand2")
        self.stop_btn.pack(side="left", padx=10)

        # Status Bar
        self.status_var = tk.StringVar()
        self.status_var.set("Initializing...")
        self.status_label = tk.Label(self.root, textvariable=self.status_var, font=("Segoe UI", 10, "italic"), bg="#f0f0f0", fg="#555")
        self.status_label.pack(pady=5)

        # Results Section
        result_frame = tk.LabelFrame(self.root, text="Analysis Results", font=("Segoe UI", 12, "bold"), bg="#f0f0f0", padx=10, pady=10)
        result_frame.pack(pady=10, padx=20, fill="both", expand=True)

        self.result_text = scrolledtext.ScrolledText(result_frame, height=12, font=("Consolas", 11), state="disabled", bg="#fff")
        self.result_text.pack(fill="both", expand=True)

        # Final Prediction Label
        self.prediction_frame = tk.Frame(self.root, bg="#f0f0f0", pady=10)
        self.prediction_frame.pack(fill="x")
        self.prediction_label = tk.Label(self.prediction_frame, text="", font=("Segoe UI", 18, "bold"), bg="#f0f0f0")
        self.prediction_label.pack()

    def load_model(self):
        try:
            device = "cuda" if torch.cuda.is_available() else "cpu"
            self.model = pipeline(
                "automatic-speech-recognition",
                model=MODEL_ID,
                device=device,
                return_timestamps="word"
            )
            self.root.after(0, lambda: self.status_var.set(f" AI Model Loaded ({device.upper()}). Ready."))
        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("Error", f"Failed to load model: {e}"))
            self.root.after(0, lambda: self.status_var.set(" Error loading model."))

    def start_recording(self):
        if not self.model:
            messagebox.showwarning("Wait", "AI Model is still loading... Please wait a moment.")
            return

        self.is_recording = True
        self.audio_frames = []
        self.start_btn.config(state="disabled", bg="#95a5a6")
        self.stop_btn.config(state="normal", bg="#e74c3c")
        self.status_var.set("ðŸŽ™ï¸ Recording in progress... Ask the question now!")
        
        # Clear previous results
        self.result_text.config(state="normal")
        self.result_text.delete(1.0, tk.END)
        self.result_text.config(state="disabled")
        self.prediction_label.config(text="")

        # Start recording in a separate thread
        threading.Thread(target=self._record_loop, daemon=True).start()

    def _record_loop(self):
        with sd.InputStream(samplerate=SAMPLE_RATE, channels=1, callback=self._audio_callback):
            while self.is_recording:
                sd.sleep(100)

    def _audio_callback(self, indata, frames, time, status):
        if self.is_recording:
            self.audio_frames.append(indata.copy())

    def stop_recording(self):
        self.is_recording = False
        self.start_btn.config(state="normal", bg="#e74c3c")
        self.stop_btn.config(state="disabled", bg="#34495e")
        self.status_var.set(" Processing audio...")

        # Save audio
        if not self.audio_frames:
            return
            
        audio_data = np.concatenate(self.audio_frames, axis=0)
        audio_data_int16 = (audio_data * 32767).astype(np.int16)
        write(FILENAME, SAMPLE_RATE, audio_data_int16)
        
        self.status_var.set(" AI is analyzing speech patterns... Please wait.")
        
        # Run analysis in thread to not freeze UI
        threading.Thread(target=self.analyze_audio, daemon=True).start()

    def analyze_audio(self):
        try:
            selected_lang = self.language_map[self.lang_combo.get()]
            
            # Run Whisper
            # generate_kwargs forces the model to use the selected language
            result = self.model(FILENAME, generate_kwargs={"language": selected_lang})
            
            full_text = result["text"]
            word_chunks = result["chunks"]

            # Calculate Clinical Metrics
            metrics = self.calculate_metrics(word_chunks)
            
            # Predict Risk
            risk_result, risk_color = self.predict_asd_risk(metrics)

            # Update GUI
            self.root.after(0, lambda: self.display_results(full_text, metrics, risk_result, risk_color))
            self.root.after(0, lambda: self.status_var.set(" Analysis Complete."))

        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("Analysis Error", str(e)))
            self.root.after(0, lambda: self.status_var.set(" Error during analysis."))

    def calculate_metrics(self, word_chunks):
        repetition_count = 0
        prolongation_count = 0
        block_count = 0
        response_time = 0.0

        # Thresholds
        BLOCK_THRESHOLD = 0.5  # Silence > 0.5s is a block
        PROLONGATION_THRESHOLD = 1.0 # Word > 1.0s is prolonged

        if len(word_chunks) > 0:
            # The start time of the first word is the response delay
            response_time = word_chunks[0]['timestamp'][0]

        for i, chunk in enumerate(word_chunks):
            word = chunk['text'].strip()
            start = chunk['timestamp'][0]
            end = chunk['timestamp'][1]
            duration = end - start
            
            # Prolongation
            if duration > PROLONGATION_THRESHOLD:
                prolongation_count += 1
            
            # Repetition
            if i > 0:
                prev_word = word_chunks[i-1]['text'].strip()
                # Remove punctuation for cleaner comparison
                curr_clean = word.translate(str.maketrans('', '', string.punctuation)).lower()
                prev_clean = prev_word.translate(str.maketrans('', '', string.punctuation)).lower()
                
                if curr_clean == prev_clean and len(curr_clean) > 0:
                    repetition_count += 1
            
            # Blocks (Pauses)
            if i > 0:
                prev_end = word_chunks[i-1]['timestamp'][1]
                pause = start - prev_end
                if pause > BLOCK_THRESHOLD:
                    block_count += 1

        return {
            "response_time": response_time,
            "repetitions": repetition_count,
            "prolongations": prolongation_count,
            "blocks": block_count
        }

    def predict_asd_risk(self, metrics):
        """
        Rule-Based Logic to determining risk.
        NOTE: This logic mimics the Random Forest decision process for the prototype.
        """
        score = 0
        reasons = []

        # 1. Delayed Response Logic
        if metrics["response_time"] > 3.0:
            score += 2
            reasons.append(f"Significant Delay ({metrics['response_time']:.1f}s)")
        elif metrics["response_time"] > 1.5:
            score += 1
            reasons.append("Minor Delay")
        
        # 2. Blocks / Pauses Logic
        if metrics["blocks"] >= 3:
            score += 2
            reasons.append("Frequent Blocks")
        elif metrics["blocks"] >= 1:
            score += 1

        # 3. Repetition Logic
        if metrics["repetitions"] >= 2:
            score += 2
            reasons.append("Speech Repetitions")
            
        # 4. Prolongation Logic
        if metrics["prolongations"] >= 1:
            score += 1
            reasons.append("Word Prolongations")

        # Final Decision
        if score >= 3:
            return f" HIGH RISK INDICATED\nReasons: {', '.join(reasons)}", "#c0392b" # Red
        elif score >= 1:
            return f" MODERATE RISK INDICATED\nReasons: {', '.join(reasons)}", "#d35400" # Orange
        else:
            return " LOW RISK INDICATED", "#27ae60" # Green

    def display_results(self, text, metrics, risk_text, color):
        self.result_text.config(state="normal")
        self.result_text.delete(1.0, tk.END)
        
        # Display Text
        self.result_text.insert(tk.END, "--- DETECTED SPEECH ---\n", "header")
        self.result_text.insert(tk.END, f"\"{text}\"\n\n")
        
        # Display Metrics
        self.result_text.insert(tk.END, "--- CLINICAL MARKERS ---\n", "header")
        self.result_text.insert(tk.END, f" Initial Response Time: {metrics['response_time']:.2f} sec\n")
        self.result_text.insert(tk.END, f" Silent Blocks (Pauses): {metrics['blocks']}\n")
        self.result_text.insert(tk.END, f" Repetitions (Stutter): {metrics['repetitions']}\n")
        self.result_text.insert(tk.END, f"Prolongations (Long words): {metrics['prolongations']}\n")
        
        # Styling
        self.result_text.tag_config("header", font=("Segoe UI", 11, "bold"))
        
        self.result_text.config(state="disabled")

        self.prediction_label.config(text=risk_text, fg=color)


if __name__ == "__main__":
    root = tk.Tk()
    app = ASDScreeningApp(root)
    root.mainloop()
